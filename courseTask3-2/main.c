#include<stdio.h>
#include<stdlib.h>
int main(void) {
    
    /**
     * Предположим, что пользователь ввёл b = 5.
     * Для примера, пусть при объявлении, у переменных c, b, y, n следующие адреса:
     * c = 0x0028FEDB, b = 0x0028FED0, y = 0x0028FEC8, n = 0x0028FEB8
     */
    char *p, c;
    int *a, b;
    float *x, y = 3.5;
    double *m, n;

    /**
     * Вывод адресов.
     */
    printf("Variable pointers: c=%p, b=%p, y=%p, n=%p, p=%p, a=%p, x=%p, m=%p\n", &c, &b, &y, &n, &p, &a, &x, &m);

    /**
     * Значение указателя a теперь равно 0x0028FED0, это указатель на содержимое переменной b.
     */
    a = &b;

    printf("  Enter b = ");
    
    /* ОШИБКА: scan("%d", a); */
    /**
     * По адресу 0x0028FED0 (указатель a) записывается значение, считанное из потока ввода.
     * Предположим, что пользователь ввёл 5.
     * Поскольку указатель a указывает на содержимое переменной b, значение b теперь стало 5.
     */
    scanf("%d", a);
    
    /**
     * Будет выведено:
     * a=0028FED0      *a=5    b=5
     * a=0028FED0, потому что указатель не изменялся и указывает на b, а адрес b = 0x0028FED0.
     * *a=5, потому что a указывает на переменную b, в которой записано значение 5.
     * b=5, потому что содержимое переменной b равно 5
     */
    printf("a=%p\t*a=%d\tb=%d\n", a, *a, b);
    
    /* ОШИБКА: p = a; */
    /**
     * Перезаписываем указатель:
     * Теперь p указывает туда же, куда и указывает a (a указывает на содержимое переменной b).
     * Поскольку указатели разных типов, при разименовывании p получится первый байт переменной b.
     * p теперь равен 0x0028FED0
     */
    p = (char*)a;
    
    /**
     * Обращаемся по указателю p и получаем от туда значение.
     * Это значение = первый байт переменной b, значение которой равно 5.
     * Так как 5 не выходит за границы одного байта, в c будет значение 5.
     */
    c=*p; /* в c записываем значение по адресу p */

    /**
     * В первый байт b (соответствует 4 байту числа) записываем четвёртый байт b
     * (соответствует 1 байту числа)
     * Так как 5 не выходит за границы одного байта, 1 байт числа = 00000000,
     * то b теперь будет равно 0.
     */
    *p=*(p+3); /* значение по адресу p должно быть равно значению по адресу p + 3 */

    /**
     * В 4 байт b (соответствует 1 байту числа) записываем c, которое равно 5.
     * Получается, b в двоичной записи равно:
     * 00000101 00000000 00000000 00000000
     * В десятичной записи: 2 ^ 24 + 2 ^ 26 = 83886080
     */
    *(p+3)=c; /* значение по адресу p + 3 должно быть равно c */

    /**
     * Выводится:
     * p=0028FED0      c=5     a=0028FED0      b=83886080
     * (см. предыдущие преобразования)
     */
    printf("p=%p\tc=%d\ta=%p\tb=%d\n", p, c, a, b);

    /**
     * указатель x теперь указывает на y (0x0028FEC8)
     */
    x = &y; /* в указатель x записываем адрес y */

    /**
     * Выводится:
     * x=0028FEC8      *x=3.500000     y=3.500000
     * потому что адрес y = 0x0028FEC8,
     * значение y = 3.5
     */
    printf("x=%p\t*x=%f\ty=%f\n", x, *x, y);
    
    /* ОШИБКА: a = x; */
    /**
     * Перезаписываем указатель:
     * Теперь a указывает туда же, куда и указывает x (x указывает на содержимое переменной y).
     * Переменная y типа float, но указатель a - типа int*, а значит, он будет рассматривать
     * содержимое переменной y как целое число.
     * a = 0x0028FEC8
     */
    a = (int*)x;
    
    /**
     * Значение по адресу a должно быть равно значению по адресу x.
     * Так как тип указателя a - int*, а тип указателя x - float*,
     * происходит неявное преобразование типов, остаток y (y = 3.5) отбрасывается.
     * Несмотря на то, что y - float, в него записывается запись значения 3 как integer.
     * Получается в памяти будет записано: 00000011 00000000 00000000 00000000
     * Но считываться значение будет так: 00000000 00000000 00000000 00000011
     * Если перевести этот код в число с плавающей точкой, получится 0
     */
    *a = *x;
    
    /* ОШИБКА:     pintf("a=%p\t*a=%d\tx=%p\t*x=%f\ty=%f\n",
           a, *a, x, *x, y); */
    /**
     * Выводит: a=0028FEC8      *a=3    x=0028FEC8      *x=0.000000     y=0.000000
     * a=0028FEC8, потому что адрес остался неизменным - 0x0028FEC8
     * *a = 3, потому что a типа int*, соответственно воспринимает значение как int, 00000011 = 3
     * x=0028FEC8, потому что адрес остался неизменным
     * *x=0.000000 (см. предыдущий блок с комментариями)
     * y=0.000000 (см. предыдущий блок с комментариями)
     */
    printf("a=%p\t*a=%d\tx=%p\t*x=%f\ty=%f\n",
       a, *a, x, *x, y);

    /**
     * Теперь a указывает на 0x0028FED0
     */
    a = &b; /* в указатель a записываем адрес b */
    
    /* ОШИБКА: y = 12345,6789; */
    y = 12345.6789;
    
    /**
     * Выводится: x=0028FEC8      *x=12345.678711 y=12345.678711
     */
    printf("x=%p\t*x=%f\ty=%f\n", x, *x, y);
    
    /* ОШИБКА: p = x; */
    /**
     * Перезаписываем указатель:
     * Теперь p указывает туда же, куда и указывает x (x указывает на содержимое переменной y).
     * Поскольку указатели разных типов, при разименовывании p получится первый байт переменной y.
     * p теперь равен 0x0028FEC8
     */
    p = (char*)x;

    /**
     * Обращаемся по указателю p и получаем от туда значение.
     * Это значение = первый байт переменной y, значение которой равно 12345.6789
     */
    c=*p; /* в c записываем значение, на которое указывает указатель p */

    /**
     * В первый байт y (соответствует 4 байту числа) записываем четвёртый байт y
     * (соответствует 1 байту числа в IEEE-754)
     */
    *p=*(p+3); /* значению по адресу p присваивается значение по адресу p + 3 */

    /**
     * В 4 байт y (соответствует 1 байту числа) записываем c.
     * Фактически, поменялись местами 1 байт с 4 байтом в IEEE-754 кодировании.
     * Было: 01000110 01000000 11100110 10110111 = 12345.6789
     * Стало: 10110111 01000000 11100110 01000110 = -0.000011497706509544514
     */
    *(p+3)=c; /* значению по адресу p + 3 присваивается значение c */

    /**
     * Выводится: p=0028FEC8      c=-73   x=0028FEC8      y=-0.000011
     * p=0028FEC8, потому что 0x0028FEC8 - адрес y
     * c=-73, потому что 10110111 в двоичной системе = -73
     * x=0028FEC8, потому что 0x0028FEC8 - адрес y,
     * y=-0.000011 (см. предыдущий комментарий)
     */
    printf("p=%p\tc=%d\tx=%p\ty=%f\n", p, c, x, y);

    /**
     * m теперь указывает на n
     */
    m = &n;

    /**
     * Выводит: m=0028FEB8      *m=0.000000     n=0.000000
     * m=0028FEB8, потому что адрес n = 0x0028FEB8
     * *m= мусор, который оказался по адресу 0x0028FEB8
     * n= тот же самый мусор
     */
    printf("m=%p\t*m=%lf\tn=%lf\n", m, *m, n);

    n = 5.5;

    /**
     * Выводит: m=0028FEB8      *m=5.500000     n=5.500000
     * m=0028FEB8, потому что адрес n = 0x0028FEB8
     * *m=5.500000, потому что только что присвоили значению, на которое этот указатель указывает, 5.5
     * n=5.500000, потому что только что было присвоение
     */
    printf("m=%p\t*m=%lf\tn=%lf\n", m, *m, n);

    /**
     * Множественное присваивание.
     * Теперь b = 1, n = 1.7, y = 1.7
     */
    b = n = y = 1.7;
    
    /* ОШИБКА: print("b=%d\ty=%f\tn=%lf\n", b, y, n); */
    /**
     * Выводит: b=1     y=1.700000      n=1.700000
     * (см. предыдущий комментарий)
     */
    printf("b=%d\ty=%f\tn=%lf\n", b, y, n);
    
    /**
     * Выводит: *a=1    *x=1.700000     *m=1.700000
     * потому что a указывает на b, x указывает на y, m указывает на n
     */
    printf("*a=%d\t*x=%f\t*m=%lf\n", *a, *x, *m);

    /**
     * m указывает на n (0x0028FEB8)
     */

    /**
     * После увеличения на 2, m указывает на 0x0028FEB8 + 0x10 = 0x0028FEC8
     */
    m += 2;
    /**
     * После инкремента, m указывает на 0x0028FEB8 + 0x8 = 0x0028FEC0
     */
    /*m++;*/
    
    /**
     * Выводит: n=1.700000      n=0028FEB8      m=0028FED0
     * n=1.7, потому что это значение было присвоено
     * n=0028FEB8, потому что это изначальный адрес n.
     * m=0028FED0 (см. предыдущий комментарий)
     */
    printf("n=%lf\tn=%p\tm=%p\n", n, &n, m);

    /**
     * По адресу m записывается 5.0 - 5.5 + 1 = 0.5
     */
    *m = (float)*a - n + (int)*x;

    /**
     * Выводится: m=0028FED0      *m=0.300000
     * (см. предыдущий комментарий)
     */
    printf("m=%p\t*m=%lf\n", m, *m);

    /**
     * Вывод значений.
     */
    printf("Values: p=%p, c=%d, a=%p, b=%d, x=%p, y=%f, m=%p, n=%lf\n", p, c, a, b, x, y, m, n);

    system("pause");
    
    /* ОШИБКА: return0; */
    return 0;

    /*
    При m += 2

     */

}